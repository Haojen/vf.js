!function(n,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t=e();for(var o in t)("object"==typeof exports?exports:n)[o]=t[o]}}(window,(function(){return function(n){var e={};function t(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return n[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=n,t.c=e,t.d=function(n,e,o){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)t.d(o,r,function(e){return n[e]}.bind(null,r));return o},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=2)}({2:function(n,e,t){"use strict";var o,r=this&&this.__extends||(o=function(n,e){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)e.hasOwnProperty(t)&&(n[t]=e[t])})(n,e)},function(n,e){function t(){this.constructor=n}o(n,e),n.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)});Object.defineProperty(e,"__esModule",{value:!0});var i=function(n){function e(){var t=n.call(this,e.Vertex,e.Fragment.replace(/__ANGLE_STEP_SIZE__/gi,""+.5.toFixed(7)).replace(/__DIST__/gi,"20.0"))||this;t.DEG_TO_RAD=Math.PI/180,t.uniforms.glowColor=new Float32Array([0,0,0,1]);var o=20,r=4,i=0,l=16777215,a=!1;return t.color=l,t.outerStrength=r,t.innerStrength=i,t.distance=o,t.knockout=a,t}return r(e,n),Object.defineProperty(e.prototype,"distance",{get:function(){return this.uniforms.dist},set:function(n){this.padding=n,this.uniforms.dist=n},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"color",{get:function(){return this.rgb2hex(this.uniforms.glowColor)},set:function(n){this.hex2rgb(n,this.uniforms.glowColor)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outerStrength",{get:function(){return this.uniforms.outerStrength},set:function(n){this.uniforms.outerStrength=n},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"innerStrength",{get:function(){return this.uniforms.innerStrength},set:function(n){this.uniforms.innerStrength=n},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"knockout",{get:function(){return this.uniforms.knockout},set:function(n){this.uniforms.knockout=n},enumerable:!0,configurable:!0}),e.prototype.hex2rgb=function(n,e){return(e=e||[])[0]=(n>>16&255)/255,e[1]=(n>>8&255)/255,e[2]=(255&n)/255,e},e.prototype.rgb2hex=function(n){return(255*n[0]<<16)+(255*n[1]<<8)+(255*n[2]|0)},e.Fragment="\n    varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float outerStrength;\nuniform float innerStrength;\nuniform float dist;\nuniform vec4 glowColor;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform bool knockout;\n\nconst float PI = 3.14159265358979323846264;\n\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\n\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n\n    float totalAlpha = 0.0;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    float _angleStepSize = 1.0 / 0.1 / dist;\n    float angleStepSize = min(_angleStepSize, PI * 2.0);\n    float angleStepNum = ceil(PI * 2.0 / angleStepSize);\n    float maxTotalAlpha = angleStepNum * dist * (dist + 1.0) / 2.0;\n\n    float angle = 0.0;\n    for (float i = 0.0; i < PI * 2.0; i += 0.0) {\n       direction = vec2(cos(angle), sin(angle)) * px;\n\n       float curDistance = 0.0;\n\n       for (float j = 0.0; j < 1.0; j += 0.0) {\n           displaced = clamp(vTextureCoord + direction * \n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\n\n           curColor = texture2D(uSampler, displaced);\n\n           totalAlpha += (dist - curDistance) * curColor.a;\n           curDistance++;\n           if(curDistance >= dist) {\n               break;\n           }\n       }\n       angle += angleStepSize;\n       if(angle >= PI * 2.0) {\n           break;\n       }\n\n    }\n    \n    curColor = texture2D(uSampler, vTextureCoord);\n\n    float alphaRatio = (totalAlpha / maxTotalAlpha);\n\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\n\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n    \n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      gl_FragColor = innerColor + outerGlowColor;\n    }\n}\n\n\n",e.Vertex="\n    attribute vec2 aVertexPosition;\n    attribute vec2 aTextureCoord;\n\n    uniform mat3 projectionMatrix;\n\n    varying vec2 vTextureCoord;\n\n    void main(void)\n    {\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n        vTextureCoord = aTextureCoord;\n    }\n",e}(gui.Filter);e.FilterGlow=i}})}));
//# sourceMappingURL=FilterGlow.js.map